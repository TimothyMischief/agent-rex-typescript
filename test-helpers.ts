// This file is auto-generated by organjsm tangle. Do not edit directly.
// Source: index.org

// [[file:index.org::22464]]
/**
 * A controllable async stream for testing.
 * Push values manually and control completion/errors.
 */
export class TestStream<T> implements AsyncIterable<T> {
  private queue: T[] = []
  private waiting: ((value: IteratorResult<T>) => void) | null = null
  private done = false
  private error: Error | null = null

  /**
   * Push a value to the stream.
   * If a consumer is waiting, it receives the value immediately.
   */
  push(value: T): void {
    if (this.done) throw new Error('Cannot push to completed stream')
    if (this.waiting) {
      const resolve = this.waiting
      this.waiting = null
      resolve({ value, done: false })
    } else {
      this.queue.push(value)
    }
  }

  /**
   * Push multiple values to the stream.
   */
  pushAll(...values: T[]): void {
    values.forEach(v => this.push(v))
  }

  /**
   * Signal that the stream is complete.
   * No more values can be pushed after this.
   */
  complete(): void {
    this.done = true
    if (this.waiting) {
      const resolve = this.waiting
      this.waiting = null
      resolve({ value: undefined as any, done: true })
    }
  }

  /**
   * Signal an error on the stream.
   */
  throw(error: Error): void {
    this.error = error
    this.done = true
    // If someone is waiting, we need to reject them
    // However, we can't reject a resolve function directly.
    // The error will be thrown on the next next() call.
    // Clear waiting so they re-check error state.
    if (this.waiting) {
      const resolve = this.waiting
      this.waiting = null
      // Resolve with done=true, the error will be thrown on next call
      // Actually, we need to handle this by having next() check error first
      // which it already does. But for pending waiters, we need to wake them.
      // Since we can't reject, we resolve with done and let next() throw.
      resolve({ value: undefined as any, done: true })
    }
  }

  [Symbol.asyncIterator](): AsyncIterator<T> {
    return {
      next: async (): Promise<IteratorResult<T>> => {
        if (this.error) throw this.error
        if (this.queue.length > 0) {
          return { value: this.queue.shift()!, done: false }
        }
        if (this.done) {
          return { value: undefined as any, done: true }
        }
        return new Promise(resolve => {
          this.waiting = resolve
          // Check for error after setting waiting
          if (this.error) {
            this.waiting = null
            throw this.error
          }
        })
      }
    }
  }
}
// unnamed ends here

// [[file:index.org::22594]]
/**
 * Collect all values from a stream into an array.
 * The stream must complete for this to resolve.
 */
export async function collect<T>(stream: AsyncIterable<T>): Promise<T[]> {
  const values: T[] = []
  for await (const value of stream) values.push(value)
  return values
}

/**
 * Collected value with timing metadata.
 */
export interface TimedValue<T> {
  value: T
  /** Milliseconds since collection started */
  elapsed: number
}

/**
 * Collect all values from a stream with timing information.
 * Useful for testing time-based operations.
 */
export async function collectWithTime<T>(
  stream: AsyncIterable<T>
): Promise<TimedValue<T>[]> {
  const values: TimedValue<T>[] = []
  const start = Date.now()
  for await (const value of stream) {
    values.push({ value, elapsed: Date.now() - start })
  }
  return values
}

/**
 * Collect exactly N values from a stream.
 * Useful for testing infinite or long-running streams.
 */
export async function collectN<T>(
  n: number,
  stream: AsyncIterable<T>
): Promise<T[]> {
  const values: T[] = []
  for await (const value of stream) {
    values.push(value)
    if (values.length >= n) break
  }
  return values
}

/**
 * Collect values until a predicate returns true.
 * The matching value is included in the result.
 */
export async function collectUntil<T>(
  predicate: (value: T) => boolean,
  stream: AsyncIterable<T>
): Promise<T[]> {
  const values: T[] = []
  for await (const value of stream) {
    values.push(value)
    if (predicate(value)) break
  }
  return values
}

/**
 * Collect values with a timeout.
 * Returns whatever was collected when the timeout expires.
 */
export async function collectWithTimeout<T>(
  ms: number,
  stream: AsyncIterable<T>
): Promise<T[]> {
  const values: T[] = []
  const iterator = stream[Symbol.asyncIterator]()
  const timeout = new Promise<'timeout'>(resolve => 
    setTimeout(() => resolve('timeout'), ms)
  )

  while (true) {
    const result = await Promise.race([iterator.next(), timeout])
    if (result === 'timeout') break
    if (result.done) break
    values.push(result.value)
  }

  return values
}
// unnamed ends here

// [[file:index.org::22706]]
/**
 * Options for marble stream creation.
 */
export interface MarbleOptions<T> {
  /** Map of characters to their emission values */
  values?: Record<string, T>
  /** Time per frame (each '-' or character), default 10ms */
  frameTime?: number
  /** Error to throw when '#' is encountered */
  error?: Error
}

/**
 * Create a stream from a marble diagram string.
 * 
 * Marble syntax:
 * - '-' advances time by one frame
 * - Letters emit the corresponding value from the values map
 * - '|' completes the stream
 * - '#' errors the stream
 * - '()' groups emissions at the same time point
 * 
 * @example
 * const stream = marble('-a-b-|', { a: 1, b: 2 })
 * // Emits 1 at 10ms, 2 at 30ms, completes at 50ms
 */
export async function* marble<T>(
  diagram: string,
  options: MarbleOptions<T> = {}
): AsyncGenerator<T, void, void> {
  const { values = {} as Record<string, T>, frameTime = 10, error = new Error('marble error') } = options
  let i = 0
  let inGroup = false
  let groupValues: T[] = []

  while (i < diagram.length) {
    const char = diagram[i]

    if (char === '-') {
      if (!inGroup) await delay(frameTime)
    } else if (char === '|') {
      return
    } else if (char === '#') {
      throw error
    } else if (char === '(') {
      inGroup = true
      groupValues = []
    } else if (char === ')') {
      inGroup = false
      for (const v of groupValues) yield v
      await delay(frameTime)
    } else if (char === ' ') {
      // Ignore spaces (for readability)
    } else {
      const value = values[char] ?? (char as unknown as T)
      if (inGroup) {
        groupValues.push(value)
      } else {
        yield value
        await delay(frameTime)
      }
    }
    i++
  }
}

function delay(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms))
}

/**
 * Parse a marble diagram into a sequence of events for testing.
 * Returns the expected values and their relative times.
 */
export function parseMarble<T>(
  diagram: string,
  options: MarbleOptions<T> = {}
): Array<{ time: number; value: T }> {
  const { values = {} as Record<string, T>, frameTime = 10 } = options
  const events: Array<{ time: number; value: T }> = []
  let time = 0
  let i = 0
  let inGroup = false

  while (i < diagram.length) {
    const char = diagram[i]

    if (char === '-') {
      if (!inGroup) time += frameTime
    } else if (char === '|' || char === '#') {
      // Completion/error markers don't emit values
    } else if (char === '(') {
      inGroup = true
    } else if (char === ')') {
      inGroup = false
      time += frameTime
    } else if (char === ' ') {
      // Ignore spaces
    } else {
      const value = values[char] ?? (char as unknown as T)
      events.push({ time, value })
      if (!inGroup) time += frameTime
    }
    i++
  }

  return events
}
// unnamed ends here

// [[file:index.org::22846]]
/**
 * Consume N values from a stream, discarding them.
 * Useful for advancing a stream to a certain point.
 */
export async function drainN<T>(
  n: number,
  stream: AsyncIterable<T>
): Promise<void> {
  let count = 0
  for await (const _ of stream) {
    if (++count >= n) break
  }
}

/**
 * Consume all values from a stream, discarding them.
 * Useful for ensuring a stream completes.
 */
export async function drain<T>(stream: AsyncIterable<T>): Promise<void> {
  for await (const _ of stream) { /* consume */ }
}
// unnamed ends here

// [[file:index.org::22874]]
/**
 * A record of events that occurred on a spied stream.
 */
export interface SpyEvent<T> {
  type: 'value' | 'complete' | 'error'
  value?: T
  error?: Error
  time: number
}

/**
 * A spy that records stream events for later assertion.
 */
export interface StreamSpy<T> {
  /** The wrapped stream to consume */
  stream: AsyncIterable<T>
  /** All recorded events */
  events: SpyEvent<T>[]
  /** Just the emitted values */
  values: T[]
  /** Whether the stream completed */
  completed: boolean
  /** The error if one occurred */
  error?: Error
  /** Wait for N values to be emitted */
  waitForN(n: number): Promise<T[]>
  /** Wait for completion */
  waitForComplete(): Promise<void>
}

/**
 * Wrap a stream with a spy to record all events.
 * 
 * @example
 * const spied = spy(myStream)
 * await collect(spied.stream)
 * expect(spied.values).toEqual([1, 2, 3])
 * expect(spied.completed).toBe(true)
 */
export function spy<T>(source: AsyncIterable<T>): StreamSpy<T> {
  const startTime = Date.now()
  const events: SpyEvent<T>[] = []
  const values: T[] = []
  let completed = false
  let error: Error | undefined
  let valueListeners: Array<{ count: number; resolve: (values: T[]) => void }> = []
  let completeListeners: Array<() => void> = []

  const stream: AsyncIterable<T> = {
    [Symbol.asyncIterator]() {
      const iterator = source[Symbol.asyncIterator]()
      return {
        async next(): Promise<IteratorResult<T>> {
          try {
            const result = await iterator.next()
            if (result.done) {
              completed = true
              events.push({ type: 'complete', time: Date.now() - startTime })
              completeListeners.forEach(l => l())
              return result
            }
            values.push(result.value)
            events.push({ type: 'value', value: result.value, time: Date.now() - startTime })
            checkValueListeners()
            return result
          } catch (e) {
            error = e as Error
            events.push({ type: 'error', error, time: Date.now() - startTime })
            throw e
          }
        }
      }
    }
  }

  function checkValueListeners() {
    valueListeners = valueListeners.filter(({ count, resolve }) => {
      if (values.length >= count) {
        resolve([...values])
        return false
      }
      return true
    })
  }

  return {
    stream,
    events,
    values,
    get completed() { return completed },
    get error() { return error },
    waitForN(n: number): Promise<T[]> {
      if (values.length >= n) return Promise.resolve([...values])
      return new Promise(resolve => {
        valueListeners.push({ count: n, resolve })
      })
    },
    waitForComplete(): Promise<void> {
      if (completed) return Promise.resolve()
      return new Promise(resolve => {
        completeListeners.push(resolve)
      })
    }
  }
}
// unnamed ends here

// [[file:index.org::23001]]
/**
 * Fluent assertion builder for streams.
 */
export interface StreamExpectation<T> {
  /** Assert the stream emits exactly these values */
  toEmit(expected: T[]): Promise<void>
  /** Assert the stream emits values matching a predicate */
  toEmitMatching(predicate: (values: T[]) => boolean): Promise<void>
  /** Assert the stream emits at least N values */
  toEmitAtLeast(n: number): Promise<T[]>
  /** Assert the stream completes */
  toComplete(): Promise<void>
  /** Assert the stream errors */
  toError(): Promise<Error>
  /** Assert the stream errors with a specific message */
  toErrorWith(message: string | RegExp): Promise<void>
  /** Assert the stream is empty */
  toBeEmpty(): Promise<void>
  /** Assert first N values match */
  firstN(n: number): StreamExpectation<T>
}

/**
 * Create fluent assertions for a stream.
 * 
 * @example
 * await expectStream(from([1, 2, 3])).toEmit([1, 2, 3])
 * await expectStream(empty()).toBeEmpty()
 * await expectStream(throwError(new Error('oops'))).toError()
 */
export function expectStream<T>(stream: AsyncIterable<T>): StreamExpectation<T> {
  let limit: number | undefined

  const createExpectation = (s: AsyncIterable<T>): StreamExpectation<T> => ({
    async toEmit(expected: T[]): Promise<void> {
      const actual = limit !== undefined 
        ? await collectN(limit, s)
        : await collect(s)
      if (!arraysEqual(actual, expected)) {
        throw new Error(
          `Expected stream to emit ${JSON.stringify(expected)}, but got ${JSON.stringify(actual)}`
        )
      }
    },

    async toEmitMatching(predicate: (values: T[]) => boolean): Promise<void> {
      const values = limit !== undefined
        ? await collectN(limit, s)
        : await collect(s)
      if (!predicate(values)) {
        throw new Error(
          `Stream values ${JSON.stringify(values)} did not match predicate`
        )
      }
    },

    async toEmitAtLeast(n: number): Promise<T[]> {
      const values = await collectN(n, s)
      if (values.length < n) {
        throw new Error(
          `Expected stream to emit at least ${n} values, but got ${values.length}`
        )
      }
      return values
    },

    async toComplete(): Promise<void> {
      await collect(s)
      // If we get here without error, stream completed
    },

    async toError(): Promise<Error> {
      try {
        await collect(s)
        throw new Error('Expected stream to error, but it completed')
      } catch (e) {
        return e as Error
      }
    },

    async toErrorWith(message: string | RegExp): Promise<void> {
      try {
        await collect(s)
        throw new Error('Expected stream to error, but it completed')
      } catch (e) {
        const error = e as Error
        const matches = typeof message === 'string'
          ? error.message === message
          : message.test(error.message)
        if (!matches) {
          throw new Error(
            `Expected error message to match ${message}, but got "${error.message}"`
          )
        }
      }
    },

    async toBeEmpty(): Promise<void> {
      const values = await collect(s)
      if (values.length > 0) {
        throw new Error(
          `Expected stream to be empty, but got ${JSON.stringify(values)}`
        )
      }
    },

    firstN(n: number): StreamExpectation<T> {
      limit = n
      return this
    }
  })

  return createExpectation(stream)
}

function arraysEqual<T>(a: T[], b: T[]): boolean {
  if (a.length !== b.length) return false
  return a.every((v, i) => v === b[i])
}
// unnamed ends here

// [[file:index.org::23127]]
/**
 * Options for creating an async iterable.
 */
export interface AsyncIterableOptions {
  /** Delay between emissions in milliseconds */
  delay?: number
  /** Delay before first emission */
  initialDelay?: number
}

/**
 * Create an async iterable from an array with optional timing.
 * 
 * @example
 * const stream = createAsyncIterable([1, 2, 3], { delay: 100 })
 * // Emits 1, then waits 100ms, emits 2, waits 100ms, emits 3
 */
export async function* createAsyncIterable<T>(
  values: T[],
  options: AsyncIterableOptions = {}
): AsyncGenerator<T, void, void> {
  const { delay: delayMs = 0, initialDelay = 0 } = options

  if (initialDelay > 0) {
    await new Promise(r => setTimeout(r, initialDelay))
  }

  for (let i = 0; i < values.length; i++) {
    yield values[i]
    if (delayMs > 0 && i < values.length - 1) {
      await new Promise(r => setTimeout(r, delayMs))
    }
  }
}
// unnamed ends here
