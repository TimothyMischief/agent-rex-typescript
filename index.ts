// This file is auto-generated by organjsm tangle. Do not edit directly.
// Source: index.org

// [[file:index.org::527]]
/**
 * Creates a stream that emits a single value and then completes.
 */
export async function* just<T>(
  value: T
): AsyncGenerator<T, void, void> {
  yield value
}

export const of = just
// unnamed ends here

// [[file:index.org::937]]
/**
 * Creates a stream from a Promise.
 * When the Promise resolves, the stream emits the resolved value and then completes.
 */
export async function* fromPromise<T>(promise: Promise<T>): AsyncGenerator<T, void, void> {
  const value = await promise
  yield value
}
// unnamed ends here

// [[file:index.org::1267]]
/**
 * Creates a stream from an iterable or async iterable.
 * It emits each value from the iterable in sequence.
 */
export async function* from<T>(
  iterable: Iterable<T> | AsyncIterable<T>
): AsyncGenerator<T, void, void> {
  for await (const item of iterable) yield item
}
// unnamed ends here

// [[file:index.org::1629]]
/**
 * Creates a stream that emits at regular intervals.
 * To give it a value, combine it with `constant`.
 */
export async function* periodic(intervalMs: number): AsyncGenerator<void, void, void> {
  while (true) {
    yield;
    await new Promise((resolve) => setTimeout(resolve, intervalMs));
  }
}
// unnamed ends here

// [[file:index.org::1918]]
/**
 * Creates a stream that immediately completes without emitting any values.
 */
export async function* empty(
): AsyncGenerator<never, void, void> {
  return
}
// unnamed ends here

// [[file:index.org::2126]]
/**
 * Creates a stream that never emits any values and never completes.
 * Useful for representing an infinite wait or as a placeholder.
 */
export async function* never(
): AsyncGenerator<never, void, void> {
  await new Promise(() => {})
}
// unnamed ends here

// [[file:index.org::2406]]
/**
 * Creates a stream that emits an infinite sequence of values by repeatedly applying a function to a seed value.
 */
export async function* iterate<T>(seed: T, fn: (value: T) => T): AsyncGenerator<T, void, void> {
  let current = seed;
  while (true) {
    yield current
    current = fn(current)
  }
}
// unnamed ends here

// [[file:index.org::2732]]
/**
 * Creates a stream that emits values by unfolding a seed value using a function.
 * The function returns an object containing the next value, the next seed, and a done flag
 * to indicate completion.
 */
export async function* unfold<T, S>(
  seed: S,
  fn: (seed: S) => { value: T; nextSeed: S; done: boolean }
): AsyncGenerator<T, void, void> {
  let currentSeed = seed;
  while (true) {
    const { value, nextSeed, done } = fn(currentSeed)
    if (done) return
    yield value
    currentSeed = nextSeed;
  }
}
// unnamed ends here

// [[file:index.org::3185]]
/**
 * Prepends a value to the beginning of a stream.
 */
export function startWith<T>(
  value: T
): (stream: AsyncIterable<T>) => AsyncGenerator<T, void, void>;
export function startWith<T>(
  value: T,
  stream: AsyncIterable<T>
): AsyncGenerator<T, void, void>;
export function startWith<T>(
  value: T,
  stream?: AsyncIterable<T>,
): AsyncGenerator<T, void, void> | ((stream: AsyncIterable<T>) => AsyncGenerator<T, void, void>) {
  if (stream === undefined) return (s: AsyncIterable<T>) => startWith(value, s);
  return (async function* () {
    yield value
    yield* stream
  })();
}
// unnamed ends here

// [[file:index.org::3477]]
/**
 * Concatenates multiple streams into a single stream.
 */
export async function* concat<T>(
  ...streams: AsyncIterable<T>[]
): AsyncGenerator<T, void, void> {
  for (const stream of streams) yield* stream
}
// unnamed ends here

// [[file:index.org::3869]]
/**
 * An object that can add and remove event listeners.
 * Compatible with DOM EventTarget, Node.js EventEmitter, and similar.
 */
export interface EventTargetLike<E> {
  addEventListener(type: string, listener: (event: E) => void): void
  removeEventListener(type: string, listener: (event: E) => void): void
}

/**
 * Creates a stream from events on an EventTarget-like object.
 * The event listener is automatically removed when the stream is closed.
 * 
 * @example
 * const clicks = fromEvent(button, 'click')
 * for await (const event of clicks) {
 *   console.log('clicked!', event)
 * }
 */
export function fromEvent<E = Event>(
  target: EventTargetLike<E>,
  eventName: string
): AsyncIterable<E> {
  return {
    [Symbol.asyncIterator]() {
      const queue: E[] = []
      let resolve: ((result: IteratorResult<E>) => void) | null = null
      let done = false

      const listener = (event: E) => {
        if (resolve) {
          const r = resolve
          resolve = null
          r({ value: event, done: false })
        } else queue.push(event)
      }

      target.addEventListener(eventName, listener)

      return {
        async next(): Promise<IteratorResult<E>> {
          if (queue.length > 0) return { value: queue.shift()!, done: false }
          if (done) return { value: undefined as any, done: true }
          return new Promise(r => resolve = r)
        },
        async return(): Promise<IteratorResult<E>> {
          done = true
          target.removeEventListener(eventName, listener)
          if (resolve) {
            const r = resolve
            resolve = null
            r({ value: undefined as any, done: true })
          }
          return { value: undefined as any, done: true }
        }
      }
    }
  }
}
// unnamed ends here

// [[file:index.org::4145]]
/**
 * A unary function type for pipe composition.
 */
type Fn = (arg: any) => any

/**
 * Recursively validates that each function's input matches the previous function's output.
 * If a mismatch is found, the expected type is shown in the error position.
 * 
 * Uses `In extends Parameters<First>[0]` (not the reverse) because function parameters
 * are contravariant: we need to check if In can be assigned TO the function's parameter,
 * not whether the parameter type extends In. This ensures AsyncIterable<number> properly
 * satisfies AsyncIterable<unknown>.
 */
type ValidatePipeline<Fns extends Fn[], In> =
  Fns extends [infer First extends Fn, ...infer Rest extends Fn[]]
    ? In extends Parameters<First>[0]
      ? [First, ...ValidatePipeline<Rest, ReturnType<First>>]
      : [(arg: In) => ReturnType<First>, ...Rest]
    : []

/**
 * Computes the final return type by walking through the function chain.
 */
type PipeReturn<Fns extends Fn[], In> =
  Fns extends [infer First extends Fn, ...infer Rest extends Fn[]]
    ? PipeReturn<Rest, ReturnType<First>>
    : In

/**
 * Composes functions left-to-right, passing the result of each to the next.
 * The first argument is the initial value; subsequent arguments are unary functions.
 * 
 * Uses explicit overloads for 1-10 functions for reliable type inference.
 * Pipelines with 11+ functions fall back to recursive validation.
 * 
 * @example
 * const result = pipe(
 *   from([1, 2, 3, 4, 5]),
 *   filter(x => x % 2 === 0),
 *   map(x => x * 10),
 *   take(2),
 * );
 * // result: async generator yielding 20, 40
 */
export function pipe<A>(initial: A): A;
export function pipe<A, B>(initial: A, f1: (a: A) => B): B;
export function pipe<A, B, C>(initial: A, f1: (a: A) => B, f2: (b: B) => C): C;
export function pipe<A, B, C, D>(initial: A, f1: (a: A) => B, f2: (b: B) => C, f3: (c: C) => D): D;
export function pipe<A, B, C, D, E>(initial: A, f1: (a: A) => B, f2: (b: B) => C, f3: (c: C) => D, f4: (d: D) => E): E;
export function pipe<A, B, C, D, E, F>(initial: A, f1: (a: A) => B, f2: (b: B) => C, f3: (c: C) => D, f4: (d: D) => E, f5: (e: E) => F): F;
export function pipe<A, B, C, D, E, F, G>(initial: A, f1: (a: A) => B, f2: (b: B) => C, f3: (c: C) => D, f4: (d: D) => E, f5: (e: E) => F, f6: (f: F) => G): G;
export function pipe<A, B, C, D, E, F, G, H>(initial: A, f1: (a: A) => B, f2: (b: B) => C, f3: (c: C) => D, f4: (d: D) => E, f5: (e: E) => F, f6: (f: F) => G, f7: (g: G) => H): H;
export function pipe<A, B, C, D, E, F, G, H, I>(initial: A, f1: (a: A) => B, f2: (b: B) => C, f3: (c: C) => D, f4: (d: D) => E, f5: (e: E) => F, f6: (f: F) => G, f7: (g: G) => H, f8: (h: H) => I): I;
export function pipe<A, B, C, D, E, F, G, H, I, J>(initial: A, f1: (a: A) => B, f2: (b: B) => C, f3: (c: C) => D, f4: (d: D) => E, f5: (e: E) => F, f6: (f: F) => G, f7: (g: G) => H, f8: (h: H) => I, f9: (i: I) => J): J;
export function pipe<A, B, C, D, E, F, G, H, I, J, K>(initial: A, f1: (a: A) => B, f2: (b: B) => C, f3: (c: C) => D, f4: (d: D) => E, f5: (e: E) => F, f6: (f: F) => G, f7: (g: G) => H, f8: (h: H) => I, f9: (i: I) => J, f10: (j: J) => K): K;
export function pipe<A, Fns extends Fn[]>(initial: A, ...fns: Fns & ValidatePipeline<Fns, A>): PipeReturn<Fns, A>;
export function pipe(initial: unknown, ...fns: Fn[]): unknown {
  return fns.reduce((acc, fn) => fn(acc), initial)
}
// unnamed ends here

// [[file:index.org::4350]]
/**
 * Transforms each value emitted by a stream using a provided function.
 */
export function map<T, U>(
  fn: (value: T) => U | Promise<U>
): (stream: AsyncIterable<T>) => AsyncGenerator<U, void, void>;
export function map<T, U>(
  fn: (value: T) => U | Promise<U>,
  stream: AsyncIterable<T>
): AsyncGenerator<U, void, void>;
export function map<T, U>(
  fn: (value: T) => U | Promise<U>,
  stream?: AsyncIterable<T>,
): AsyncGenerator<U, void, void> | ((stream: AsyncIterable<T>) => AsyncGenerator<U, void, void>) {
  if (stream === undefined) return (s: AsyncIterable<T>) => map(fn, s);
  return (async function* () {
    for await (const item of stream) yield await fn(item);
  })();
}
// unnamed ends here

// [[file:index.org::4735]]
/**
 * Creates a stream that emits a constant value for each item in the source stream.
 */
export function constant<U>(
  value: U
): (stream: AsyncIterable<any>) => AsyncGenerator<U, void, void>;
export function constant<U>(
  value: U,
  stream: AsyncIterable<any>
): AsyncGenerator<U, void, void>;
export function constant<U>(
  value: U,
  stream?: AsyncIterable<any>,
): AsyncGenerator<U, void, void> | ((stream: AsyncIterable<any>) => AsyncGenerator<U, void, void>) {
  if (stream === undefined) return (s: AsyncIterable<any>) => constant(value, s);
  return (async function* () {
    for await (const _ of stream) yield value
  })();
}
// unnamed ends here

// [[file:index.org::5060]]
/**
 * Accumulates values from a stream using a provided accumulator function and an initial seed value.
 */
export function scan<T, U>(
  accumulator: (acc: U, value: T) => U | Promise<U>,
  seed: U
): (stream: AsyncIterable<T>) => AsyncGenerator<U, void, void>;
export function scan<T, U>(
  accumulator: (acc: U, value: T) => U | Promise<U>,
  seed: U,
  stream: AsyncIterable<T>
): AsyncGenerator<U, void, void>;
export function scan<T, U>(
  accumulator: (acc: U, value: T) => U | Promise<U>,
  seed: U,
  stream?: AsyncIterable<T>,
): AsyncGenerator<U, void, void> | ((stream: AsyncIterable<T>) => AsyncGenerator<U, void, void>) {
  if (stream === undefined) return (s: AsyncIterable<T>) => scan(accumulator, seed, s);
  return (async function* () {
    let acc = seed
    yield acc
    for await (const item of stream) yield acc = await accumulator(acc, item)
  })();
}
// unnamed ends here

// [[file:index.org::5494]]
/**
 * Performs side effects for each value emitted by a stream without modifying the values themselves.
 * The side effect is fired without awaiting, so it does not block the stream processing.
 */
export function tap<T>(
  sideEffectFn: (value: T) => void | Promise<void>
): (stream: AsyncIterable<T>) => AsyncGenerator<T, void, void>;
export function tap<T>(
  sideEffectFn: (value: T) => void | Promise<void>,
  stream: AsyncIterable<T>
): AsyncGenerator<T, void, void>;
export function tap<T>(
  sideEffectFn: (value: T) => void | Promise<void>,
  stream?: AsyncIterable<T>,
): AsyncGenerator<T, void, void> | ((stream: AsyncIterable<T>) => AsyncGenerator<T, void, void>) {
  if (stream === undefined) return (s: AsyncIterable<T>) => tap(sideEffectFn, s);
  return (async function* () {
    for await (const item of stream) {
      sideEffectFn(item)
      yield item
    }
  })();
}
// unnamed ends here

// [[file:index.org::5835]]
/**
 * Performs side effects for each value emitted by a stream, awaiting completion before yielding.
 * Use this when the side effect must complete before processing continues.
 */
export function awaitTap<T>(
  sideEffectFn: (value: T) => void | Promise<void>
): (stream: AsyncIterable<T>) => AsyncGenerator<T, void, void>;
export function awaitTap<T>(
  sideEffectFn: (value: T) => void | Promise<void>,
  stream: AsyncIterable<T>
): AsyncGenerator<T, void, void>;
export function awaitTap<T>(
  sideEffectFn: (value: T) => void | Promise<void>,
  stream?: AsyncIterable<T>,
): AsyncGenerator<T, void, void> | ((stream: AsyncIterable<T>) => AsyncGenerator<T, void, void>) {
  if (stream === undefined) return (s: AsyncIterable<T>) => awaitTap(sideEffectFn, s);
  return (async function* () {
    for await (const item of stream) {
      await sideEffectFn(item)
      yield item
    }
  })();
}
// unnamed ends here

// [[file:index.org::6160]]
/**
 * Continues a stream with another stream once the first one completes.
 */
export function continueWith<T>(
  f: () => AsyncIterable<T>
): (stream: AsyncIterable<T>) => AsyncGenerator<T, void, void>;
export function continueWith<T>(
  f: () => AsyncIterable<T>,
  stream: AsyncIterable<T>
): AsyncGenerator<T, void, void>;
export function continueWith<T>(
  f: () => AsyncIterable<T>,
  stream?: AsyncIterable<T>,
): AsyncGenerator<T, void, void> | ((stream: AsyncIterable<T>) => AsyncGenerator<T, void, void>) {
  if (stream === undefined) return (s: AsyncIterable<T>) => continueWith(f, s);
  return (async function* () {
    yield* stream
    yield* f()
  })();
}
// unnamed ends here

// [[file:index.org::6556]]
/**
 * Flattens a stream of streams by concatenating them into a single stream.
 */
export async function* concatAll<T>(
  streamOfStreams: AsyncIterable<AsyncIterable<T>>,
): AsyncGenerator<T, void, void> {
  for await (const stream of streamOfStreams) yield* stream
}
// unnamed ends here

// [[file:index.org::6852]]
/**
 * Maps each value to a stream and concatenates the results in order.
 */
export function concatMap<T, U>(
  f: (value: T) => AsyncIterable<U>
): (stream: AsyncIterable<T>) => AsyncGenerator<U, void, void>;
export function concatMap<T, U>(
  f: (value: T) => AsyncIterable<U>,
  stream: AsyncIterable<T>
): AsyncGenerator<U, void, void>;
export function concatMap<T, U>(
  f: (value: T) => AsyncIterable<U>,
  stream?: AsyncIterable<T>,
): AsyncGenerator<U, void, void> | ((stream: AsyncIterable<T>) => AsyncGenerator<U, void, void>) {
  if (stream === undefined) return (s: AsyncIterable<T>) => concatMap(f, s);
  return (async function* () {
    for await (const item of stream) yield* f(item)
  })();
}
// unnamed ends here

// [[file:index.org::7197]]
/**
 * Filters values emitted by a stream based on a provided predicate function.
 */
export function filter<T>(
  predicate: (value: T) => boolean | Promise<boolean>
): (stream: AsyncIterable<T>) => AsyncGenerator<T, void, void>;
export function filter<T>(
  predicate: (value: T) => boolean | Promise<boolean>,
  stream: AsyncIterable<T>
): AsyncGenerator<T, void, void>;
export function filter<T>(
  predicate: (value: T) => boolean | Promise<boolean>,
  stream?: AsyncIterable<T>,
): AsyncGenerator<T, void, void> | ((stream: AsyncIterable<T>) => AsyncGenerator<T, void, void>) {
  if (stream === undefined) return (s: AsyncIterable<T>) => filter(predicate, s);
  return (async function* () {
    for await (const item of stream) if (await predicate(item)) yield item;
  })();
}
// unnamed ends here

// [[file:index.org::7645]]
/**
 * Filters out consecutive duplicate values from a stream.
 */
export async function* skipRepeats<T>(
  stream: AsyncIterable<T>,
): AsyncGenerator<T, void, void> {
  let first = true
  let lastValue: T | undefined
  for await (const item of stream) {
    if (first || item !== lastValue) {
      yield lastValue = item
      first = false
    }
  }
}
// unnamed ends here

// [[file:index.org::7747]]
/**
 * Filters out consecutive duplicate values from a stream based on a provided equality function.
 */
export function skipRepeatsWith<T>(
  equals: (a: T, b: T) => boolean | Promise<boolean>
): (stream: AsyncIterable<T>) => AsyncGenerator<T, void, void>;
export function skipRepeatsWith<T>(
  equals: (a: T, b: T) => boolean | Promise<boolean>,
  stream: AsyncIterable<T>
): AsyncGenerator<T, void, void>;
export function skipRepeatsWith<T>(
  equals: (a: T, b: T) => boolean | Promise<boolean>,
  stream?: AsyncIterable<T>,
): AsyncGenerator<T, void, void> | ((stream: AsyncIterable<T>) => AsyncGenerator<T, void, void>) {
  if (stream === undefined) return (s: AsyncIterable<T>) => skipRepeatsWith(equals, s);
  return (async function* () {
    let first = true
    let lastValue: T | undefined
    for await (const item of stream) {
      if (first || !(await equals(item, lastValue as T))) {
        yield lastValue = item
        first = false
      }
    }
  })();
}
// unnamed ends here

// [[file:index.org::8240]]
/**
 * Creates a stream that emits only the first `n` values from the source stream.
 */
export function take<T>(
  n: number
): (stream: AsyncIterable<T>) => AsyncGenerator<T, void, void>;
export function take<T>(
  n: number,
  stream: AsyncIterable<T>
): AsyncGenerator<T, void, void>;
export function take<T>(
  n: number,
  stream?: AsyncIterable<T>,
): AsyncGenerator<T, void, void> | ((stream: AsyncIterable<T>) => AsyncGenerator<T, void, void>) {
  if (stream === undefined) return (s: AsyncIterable<T>) => take(n, s);
  return (async function* () {
    let count = 0;
    for await (const item of stream) {
      if (count++ < n) yield item;
      else break;
    }
  })();
}
// unnamed ends here

// [[file:index.org::8594]]
/**
 * Creates a stream that skips the first `n` values from the source stream and emits the rest.
 */
export function skip<T>(
  n: number
): (stream: AsyncIterable<T>) => AsyncGenerator<T, void, void>;
export function skip<T>(
  n: number,
  stream: AsyncIterable<T>
): AsyncGenerator<T, void, void>;
export function skip<T>(
  n: number,
  stream?: AsyncIterable<T>,
): AsyncGenerator<T, void, void> | ((stream: AsyncIterable<T>) => AsyncGenerator<T, void, void>) {
  if (stream === undefined) return (s: AsyncIterable<T>) => skip(n, s);
  return (async function* () {
    let count = 0;
    for await (const item of stream) if (count++ >= n) yield item;
  })();
}
// unnamed ends here

// [[file:index.org::8953]]
/**
 * Creates a stream that emits values from the source stream starting from index `start` up to, but not including, index `end`.
 */
export function slice<T>(
  start: number,
  end: number
): (stream: AsyncIterable<T>) => AsyncGenerator<T, void, void>;
export function slice<T>(
  start: number,
  end: number,
  stream: AsyncIterable<T>
): AsyncGenerator<T, void, void>;
export function slice<T>(
  start: number,
  end: number,
  stream?: AsyncIterable<T>,
): AsyncGenerator<T, void, void> | ((stream: AsyncIterable<T>) => AsyncGenerator<T, void, void>) {
  if (stream === undefined) return (s: AsyncIterable<T>) => slice(start, end, s);
  return (async function* () {
    let index = 0
    for await (const item of stream) {
      if (index >= start && index < end) yield item
      if (index++ >= end) break
    }
  })();
}
// unnamed ends here

// [[file:index.org::9342]]
/**
 * Creates a stream that emits values from the source stream as long as the provided predicate function returns true.
 */
export function takeWhile<T>(
  predicate: (value: T) => boolean | Promise<boolean>
): (stream: AsyncIterable<T>) => AsyncGenerator<T, void, void>;
export function takeWhile<T>(
  predicate: (value: T) => boolean | Promise<boolean>,
  stream: AsyncIterable<T>
): AsyncGenerator<T, void, void>;
export function takeWhile<T>(
  predicate: (value: T) => boolean | Promise<boolean>,
  stream?: AsyncIterable<T>,
): AsyncGenerator<T, void, void> | ((stream: AsyncIterable<T>) => AsyncGenerator<T, void, void>) {
  if (stream === undefined) return (s: AsyncIterable<T>) => takeWhile(predicate, s);
  return (async function* () {
    for await (const item of stream) {
      if (await predicate(item)) yield item
      else break
    }
  })();
}
// unnamed ends here

// [[file:index.org::9734]]
/**
 * Creates a stream that skips values from the source stream while the provided predicate function returns true, then emits the rest of the stream.
 */
export function skipWhile<T>(
  predicate: (value: T) => boolean | Promise<boolean>
): (stream: AsyncIterable<T>) => AsyncGenerator<T, void, void>;
export function skipWhile<T>(
  predicate: (value: T) => boolean | Promise<boolean>,
  stream: AsyncIterable<T>
): AsyncGenerator<T, void, void>;
export function skipWhile<T>(
  predicate: (value: T) => boolean | Promise<boolean>,
  stream?: AsyncIterable<T>,
): AsyncGenerator<T, void, void> | ((stream: AsyncIterable<T>) => AsyncGenerator<T, void, void>) {
  if (stream === undefined) return (s: AsyncIterable<T>) => skipWhile(predicate, s);
  return (async function* () {
    let match = false
    for await (const item of stream) {
      if (!match && !(await predicate(item))) match = true
      if (match) yield item
    }
  })();
}
// unnamed ends here

// [[file:index.org::10133]]
/**
 * Creates a stream that emits values from the source stream until the provided predicate function returns true.
 * The matching value is not emitted.
 */
export function takeUntil<T>(
  predicate: (value: T) => boolean | Promise<boolean>
): (stream: AsyncIterable<T>) => AsyncGenerator<T, void, void>;
export function takeUntil<T>(
  predicate: (value: T) => boolean | Promise<boolean>,
  stream: AsyncIterable<T>
): AsyncGenerator<T, void, void>;
export function takeUntil<T>(
  predicate: (value: T) => boolean | Promise<boolean>,
  stream?: AsyncIterable<T>,
): AsyncGenerator<T, void, void> | ((stream: AsyncIterable<T>) => AsyncGenerator<T, void, void>) {
  if (stream === undefined) return (s: AsyncIterable<T>) => takeUntil(predicate, s);
  return (async function* () {
    for await (const item of stream) {
      if (await predicate(item)) break
      yield item
    }
  })();
}
// unnamed ends here

// [[file:index.org::10525]]
/**
 * Delays each value emitted by the source stream by the specified duration.
 */
export function delay<T>(
  ms: number
): (stream: AsyncIterable<T>) => AsyncGenerator<T, void, void>;
export function delay<T>(
  ms: number,
  stream: AsyncIterable<T>
): AsyncGenerator<T, void, void>;
export function delay<T>(
  ms: number,
  stream?: AsyncIterable<T>,
): AsyncGenerator<T, void, void> | ((stream: AsyncIterable<T>) => AsyncGenerator<T, void, void>) {
  if (stream === undefined) return (s: AsyncIterable<T>) => delay(ms, s);
  return (async function* () {
    for await (const item of stream) {
      await new Promise(r => setTimeout(r, ms))
      yield item
    }
  })();
}
// unnamed ends here

// [[file:index.org::10895]]
/**
 * Only emits a value from the source stream if no new value arrives within the specified duration.
 * Useful for waiting until input has "settled" (e.g., user stops typing).
 */
export function debounce<T>(
  ms: number
): (stream: AsyncIterable<T>) => AsyncGenerator<T, void, void>;
export function debounce<T>(
  ms: number,
  stream: AsyncIterable<T>
): AsyncGenerator<T, void, void>;
export function debounce<T>(
  ms: number,
  stream?: AsyncIterable<T>,
): AsyncGenerator<T, void, void> | ((stream: AsyncIterable<T>) => AsyncGenerator<T, void, void>) {
  if (stream === undefined) return (s: AsyncIterable<T>) => debounce(ms, s);
  return (async function* () {
    const iterator = stream[Symbol.asyncIterator]()
    let pending: { value: T; timer: ReturnType<typeof setTimeout> } | null = null
    let done = false
    let pendingResolve: ((value: T | null) => void) | null = null

    const emitPending = () => {
      if (pending && pendingResolve) {
        const value = pending.value
        pending = null
        pendingResolve(value)
        pendingResolve = null
      }
    }

    // Start consuming source in background
    ;(async () => {
      try {
        while (true) {
          const result = await iterator.next()
          if (result.done) {
            done = true
            // Emit any pending value immediately on completion
            if (pending) {
              clearTimeout(pending.timer)
              emitPending()
            } else if (pendingResolve) {
              const resolver: (value: T | null) => void = pendingResolve
              resolver(null)
            }
            break
          }
          // Cancel previous timer
          if (pending) clearTimeout(pending.timer)
          // Set new pending value with timer
          pending = {
            value: result.value,
            timer: setTimeout(emitPending, ms)
          }
        }
      } catch (e) {
        // Handle errors by clearing pending and re-throwing via the generator
        if (pending) clearTimeout(pending.timer)
        pending = null
        throw e
      }
    })()

    // Yield debounced values
    while (!done || pending) {
      const value = await new Promise<T | null>(resolve => {
        if (done && !pending) {
          resolve(null)
          return
        }
        pendingResolve = resolve
      })
      if (value !== null) yield value
      if (done && !pending) break
    }
  })();
}
// unnamed ends here

// [[file:index.org::11490]]
/**
 * Options for throttle behavior.
 */
export interface ThrottleOptions {
  /** Emit the first value immediately when the window starts (default: true) */
  leading?: boolean
  /** Emit the last value after the window ends (default: true) */
  trailing?: boolean
}

/**
 * Limits the rate of emissions from a stream.
 * 
 * @param ms - The throttle window duration in milliseconds
 * @param options - Configure leading/trailing edge behavior
 *   - leading: emit first value immediately (default: true)
 *   - trailing: emit last value after window (default: true)
 */
export function throttle<T>(
  ms: number,
  options?: ThrottleOptions
): (stream: AsyncIterable<T>) => AsyncGenerator<T, void, void>;
export function throttle<T>(
  ms: number,
  options: ThrottleOptions | undefined,
  stream: AsyncIterable<T>
): AsyncGenerator<T, void, void>;
export function throttle<T>(
  ms: number,
  optionsOrStream?: ThrottleOptions | AsyncIterable<T>,
  maybeStream?: AsyncIterable<T>,
): AsyncGenerator<T, void, void> | ((stream: AsyncIterable<T>) => AsyncGenerator<T, void, void>) {
  // Parse arguments: supports throttle(ms), throttle(ms, opts), throttle(ms, opts, stream)
  let options: ThrottleOptions
  let stream: AsyncIterable<T> | undefined
  
  if (maybeStream !== undefined) {
    options = (optionsOrStream as ThrottleOptions) ?? {}
    stream = maybeStream
  } else if (optionsOrStream !== undefined && typeof (optionsOrStream as any)[Symbol.asyncIterator] === 'function') {
    options = {}
    stream = optionsOrStream as AsyncIterable<T>
  } else {
    options = (optionsOrStream as ThrottleOptions) ?? {}
    stream = undefined
  }

  const { leading = true, trailing = true } = options

  if (stream === undefined) return (s: AsyncIterable<T>) => throttle(ms, options, s);
  
  const sourceStream = stream
  return (async function* () {
    let lastEmitTime = 0
    let trailingValue: T | undefined
    let hasTrailingValue = false
    let trailingTimer: ReturnType<typeof setTimeout> | null = null

    const emitTrailing = function* (): Generator<T, void, void> {
      if (hasTrailingValue && trailing) {
        yield trailingValue as T
        hasTrailingValue = false
        lastEmitTime = Date.now()
      }
    }

    for await (const item of sourceStream) {
      const now = Date.now()
      const elapsed = now - lastEmitTime

      if (elapsed >= ms) {
        // Window has passed
        if (leading) {
          yield item
          lastEmitTime = now
          hasTrailingValue = false
        } else {
          // Store for trailing
          trailingValue = item
          hasTrailingValue = true
        }
      } else {
        // Within window, store for trailing
        trailingValue = item
        hasTrailingValue = true
      }
    }

    // Emit final trailing value if any
    if (hasTrailingValue && trailing) { yield trailingValue as T }
  })();
}
// unnamed ends here

// [[file:index.org::12232]]
/**
 * Recovers from errors in a stream by providing an alternative stream.
 */
export function recoverWith<T, E = unknown>(
  recoverFn: (error: E) => AsyncIterable<T>
): (stream: AsyncIterable<T>) => AsyncGenerator<T, void, void>;
export function recoverWith<T, E = unknown>(
  recoverFn: (error: E) => AsyncIterable<T>,
  stream: AsyncIterable<T>
): AsyncGenerator<T, void, void>;
export function recoverWith<T, E = unknown>(
  recoverFn: (error: E) => AsyncIterable<T>,
  stream?: AsyncIterable<T>,
): AsyncGenerator<T, void, void> | ((stream: AsyncIterable<T>) => AsyncGenerator<T, void, void>) {
  if (stream === undefined) return (s: AsyncIterable<T>) => recoverWith(recoverFn, s);
  return (async function* () {
    try { yield* stream }
    catch (error) { yield* recoverFn(error as E) }
  })();
}
// unnamed ends here

// [[file:index.org::12892]]
/**
 * Creates a stream that immediately throws an error when consumed.
 */
export async function* throwError<E = unknown>(
    error: E
): AsyncGenerator<never, void, void> {
  throw error
}
// unnamed ends here

// [[file:index.org::13156]]
/**
 * Options for retry behavior.
 */
export interface RetryOptions {
  /** Maximum number of retry attempts (default: 3) */
  maxAttempts?: number
  /** Delay between retries in milliseconds (default: 0) */
  delayMs?: number
  /** Optional predicate to decide whether to retry based on the error */
  shouldRetry?: (error: unknown, attempt: number) => boolean
}

/**
 * Retries a stream factory when it errors.
 * 
 * @param options - Retry configuration
 * @param streamFactory - A function that creates the stream to retry
 */
export function retry<T>(
  options: RetryOptions | number
): (streamFactory: () => AsyncIterable<T>) => AsyncGenerator<T, void, void>;
export function retry<T>(
  options: RetryOptions | number,
  streamFactory: () => AsyncIterable<T>
): AsyncGenerator<T, void, void>;
export function retry<T>(
  options: RetryOptions | number,
  streamFactory?: () => AsyncIterable<T>,
): AsyncGenerator<T, void, void> | ((streamFactory: () => AsyncIterable<T>) => AsyncGenerator<T, void, void>) {
  const opts: RetryOptions = typeof options === 'number' ? { maxAttempts: options } : options
  const { maxAttempts = 3, delayMs = 0, shouldRetry = () => true } = opts

  if (streamFactory === undefined) return (sf: () => AsyncIterable<T>) => retry(opts, sf);
  
  const factory = streamFactory
  return (async function* () {
    let attempt = 0
    while (true) {
      try {
        yield* factory()
        return // Success, exit
      } catch (error) {
        attempt++
        if (attempt >= maxAttempts || !shouldRetry(error, attempt)) { throw error }
        if (delayMs > 0) { await new Promise(r => setTimeout(r, delayMs)) }
        // Continue to next attempt
      }
    }
  })();
}
// unnamed ends here

// [[file:index.org::13942]]
type RaceResult<T, O> =
  | { type: 'inner'; index: number; value: T }
  | { type: 'outer'; value: O }
  | { type: 'outerDone' }

/**
 * Races inner iterators against an outer stream that produces new iterables.
 * Useful for mergeAll/chain where we need to race existing inner streams
 * while also listening for new streams from the outer source.
 */
async function* raceIteratorsWithOuter<T, O>(
  outerIterator: AsyncIterator<O>,
  getInnerIterator: (value: O) => AsyncIterator<T>
): AsyncGenerator<RaceResult<T, O>, void, void> {
  const innerIterators: AsyncIterator<T>[] = []
  const pending = new Map<number | 'outer', Promise<{ key: number | 'outer'; result: IteratorResult<any> }>>()

  // Start listening to outer
  pending.set('outer', outerIterator.next().then(result => ({ key: 'outer' as const, result })))

  while (pending.size > 0) {
    const { key, result } = await Promise.race(pending.values())

    if (key === 'outer') {
      if (result.done) {
        pending.delete('outer')
        yield { type: 'outerDone' }
      } else {
        yield { type: 'outer', value: result.value }
        // Add new inner iterator
        const innerIndex = innerIterators.length
        const innerIterator = getInnerIterator(result.value)
        innerIterators.push(innerIterator)
        pending.set(innerIndex, innerIterator.next().then(result => ({ key: innerIndex, result })))
        // Continue listening to outer
        pending.set('outer', outerIterator.next().then(result => ({ key: 'outer' as const, result })))
      }
    } else {
      // Inner iterator result
      const index = key as number
      if (result.done) pending.delete(index)
      else {
        yield { type: 'inner', index, value: result.value }
        pending.set(index, innerIterators[index].next().then(result => ({ key: index, result })))
      }
    }
  }
}
// unnamed ends here

// [[file:index.org::14042]]
/**
 * Merges multiple streams into a single stream, emitting values as they arrive.
 */
export async function* merge<T>(
  ...streams: AsyncIterable<T>[]
): AsyncGenerator<T, void, void> {
  const iterators = streams.map(s => s[Symbol.asyncIterator]())
  for await (const { value } of raceIterators(iterators)) yield value
}
// unnamed ends here

// [[file:index.org::14463]]
/**
 * Flattens a stream of streams by merging them into a single stream.
 */
export async function* mergeAll<T>(
  streamOfStreams: AsyncIterable<AsyncIterable<T>>,
): AsyncGenerator<T, void, void> {
  const outerIterator = streamOfStreams[Symbol.asyncIterator]()
  for await (const result of raceIteratorsWithOuter(outerIterator, s => s[Symbol.asyncIterator]()))
    if (result.type === 'inner') yield result.value
}
// unnamed ends here

// [[file:index.org::14794]]
/**
 * Maps each value from the source stream to a new stream and flattens the resulting streams into a single stream.
 */
export function chain<T, U>(
  fn: (value: T) => AsyncIterable<U>
): (stream: AsyncIterable<T>) => AsyncGenerator<U, void, void>;
export function chain<T, U>(
  fn: (value: T) => AsyncIterable<U>,
  stream: AsyncIterable<T>
): AsyncGenerator<U, void, void>;
export function chain<T, U>(
  fn: (value: T) => AsyncIterable<U>,
  stream?: AsyncIterable<T>,
): AsyncGenerator<U, void, void> | ((stream: AsyncIterable<T>) => AsyncGenerator<U, void, void>) {
  if (stream === undefined) return (s: AsyncIterable<T>) => chain(fn, s);
  return (async function* () {
    const outerIterator = stream[Symbol.asyncIterator]()
    for await (const result of raceIteratorsWithOuter(outerIterator, v => fn(v)[Symbol.asyncIterator]())) {
      if (result.type === 'inner') yield result.value
    }
  })();
}

export const flatMap = chain
// unnamed ends here

// [[file:index.org::15243]]
/**
 * Maps each value to a new stream, cancelling the previous inner stream when a new value arrives.
 * Only values from the most recent inner stream are emitted.
 * 
 * Useful for scenarios like autocomplete where only the latest request matters.
 */
export function switchMap<T, U>(
  fn: (value: T) => AsyncIterable<U>
): (stream: AsyncIterable<T>) => AsyncGenerator<U, void, void>;
export function switchMap<T, U>(
  fn: (value: T) => AsyncIterable<U>,
  stream: AsyncIterable<T>
): AsyncGenerator<U, void, void>;
export function switchMap<T, U>(
  fn: (value: T) => AsyncIterable<U>,
  stream?: AsyncIterable<T>,
): AsyncGenerator<U, void, void> | ((stream: AsyncIterable<T>) => AsyncGenerator<U, void, void>) {
  if (stream === undefined) return (s: AsyncIterable<T>) => switchMap(fn, s);
  return (async function* () {
    const outerIterator = stream[Symbol.asyncIterator]()
    let currentInnerIterator: AsyncIterator<U> | null = null
    let outerDone = false
    
    type PendingResult = 
      | { type: 'outer'; result: IteratorResult<T> }
      | { type: 'inner'; result: IteratorResult<U> }

    const pending = new Map<'outer' | 'inner', Promise<PendingResult>>()

    // Start listening to outer
    pending.set('outer', outerIterator.next().then(result => ({ type: 'outer' as const, result })))

    while (pending.size > 0) {
      const winner = await Promise.race(pending.values())

      if (winner.type === 'outer') {
        if (winner.result.done) {
          outerDone = true
          pending.delete('outer')
          // Continue processing current inner stream if any
        } else {
          // Cancel current inner stream (by removing from pending and not calling return)
          pending.delete('inner')
          // Start new inner stream
          currentInnerIterator = fn(winner.result.value)[Symbol.asyncIterator]()
          pending.set('inner', currentInnerIterator.next().then(result => ({ type: 'inner' as const, result })))
          // Continue listening to outer
          pending.set('outer', outerIterator.next().then(result => ({ type: 'outer' as const, result })))
        }
      } else {
        // Inner result
        if (winner.result.done) {
          pending.delete('inner')
          currentInnerIterator = null
          // If outer is also done, we're finished
        } else {
          yield winner.result.value
          // Continue listening to current inner
          pending.set('inner', currentInnerIterator!.next().then(result => ({ type: 'inner' as const, result })))
        }
      }
    }
  })();
}
// unnamed ends here

// [[file:index.org::15761]]
/**
 * Extracts the element type from an AsyncIterable.
 */
type AsyncIterableValue<T> = T extends AsyncIterable<infer U> ? U : never

/**
 * Maps a tuple of AsyncIterables to a tuple of their element types.
 */
type LatestValues<T extends readonly AsyncIterable<any>[]> = {
  [K in keyof T]: AsyncIterableValue<T[K]>
}

/**
 * Combines multiple streams into a single stream that emits a tuple of the latest values
 * from each input stream whenever any of them emit a new value.
 * 
 * Type-safe: preserves individual stream types in the output tuple.
 */
export async function* latest<T extends readonly AsyncIterable<any>[]>(
  streams: [...T],
): AsyncGenerator<LatestValues<T>, void, void> {
  const iterators = streams.map(s => s[Symbol.asyncIterator]())
  const latestValues: any[] = new Array(streams.length)
  const hasValue: boolean[] = new Array(streams.length).fill(false)
  let hasAllValues = false

  for await (const { index, value } of raceIterators(iterators)) {
    latestValues[index] = value
    hasValue[index] = true
    if (!hasAllValues) hasAllValues = hasValue.every(Boolean)
    if (hasAllValues) yield [...latestValues] as LatestValues<T>
  }
}
// unnamed ends here

// [[file:index.org::16182]]
/**
 * Applies the latest function from a stream of functions to the latest value from a stream of values.
 */
export async function* applyLatest<T, U>(
  fnStream: AsyncIterable<(value: T) => U>,
  valueStream: AsyncIterable<T>,
): AsyncGenerator<U, void, void> {
  yield* map(
    ([fn, value]) => fn(value),
    latest([fnStream, valueStream]),
  );
}
// unnamed ends here

// [[file:index.org::16467]]
/**
 * Creates a stream that emits values from the source stream until another stream emits a value.
 */
export function untilStream<T, S = unknown>(
  stopStream: AsyncIterable<S>
): (sourceStream: AsyncIterable<T>) => AsyncGenerator<T, void, void>;
export function untilStream<T, S = unknown>(
  stopStream: AsyncIterable<S>,
  sourceStream: AsyncIterable<T>
): AsyncGenerator<T, void, void>;
export function untilStream<T, S = unknown>(
  stopStream: AsyncIterable<S>,
  sourceStream?: AsyncIterable<T>,
): AsyncGenerator<T, void, void> | ((sourceStream: AsyncIterable<T>) => AsyncGenerator<T, void, void>) {
  if (sourceStream === undefined) return (s: AsyncIterable<T>) => untilStream(stopStream, s);
  return (async function* () {
    const sourceIterator = sourceStream[Symbol.asyncIterator]()
    const stopIterator = stopStream[Symbol.asyncIterator]()
    const iterators: AsyncIterator<T | S>[] = [sourceIterator, stopIterator]

    for await (const { index, value } of raceIterators(iterators)) {
      if (index === 1) break // stopStream emitted
      yield value as T
    }
  })();
}
// unnamed ends here

// [[file:index.org::16832]]
/**
 * Creates a stream that starts emitting values from the source stream only after another stream emits a value.
 */
export function sinceStream<T, S = unknown>(
  startStream: AsyncIterable<S>
): (sourceStream: AsyncIterable<T>) => AsyncGenerator<T, void, void>;
export function sinceStream<T, S = unknown>(
  startStream: AsyncIterable<S>,
  sourceStream: AsyncIterable<T>
): AsyncGenerator<T, void, void>;
export function sinceStream<T, S = unknown>(
  startStream: AsyncIterable<S>,
  sourceStream?: AsyncIterable<T>,
): AsyncGenerator<T, void, void> | ((sourceStream: AsyncIterable<T>) => AsyncGenerator<T, void, void>) {
  if (sourceStream === undefined) return (s: AsyncIterable<T>) => sinceStream(startStream, s);
  return (async function* () {
    const sourceIterator = sourceStream[Symbol.asyncIterator]()
    const startIterator = startStream[Symbol.asyncIterator]()
    const iterators: AsyncIterator<T | S>[] = [sourceIterator, startIterator]
    let started = false

    for await (const { index, value } of raceIterators(iterators)) {
      if (index === 1) {
        started = true
        continue
      }
      if (started) yield value as T
    }
  })();
}
// unnamed ends here

// [[file:index.org::17196]]
/**
 * Collects values into arrays of the specified size, emitting each buffer when full.
 * The final buffer may be smaller if the source completes.
 */
export function buffer<T>(
  size: number
): (stream: AsyncIterable<T>) => AsyncGenerator<T[], void, void>;
export function buffer<T>(
  size: number,
  stream: AsyncIterable<T>
): AsyncGenerator<T[], void, void>;
export function buffer<T>(
  size: number,
  stream?: AsyncIterable<T>,
): AsyncGenerator<T[], void, void> | ((stream: AsyncIterable<T>) => AsyncGenerator<T[], void, void>) {
  if (stream === undefined) return (s: AsyncIterable<T>) => buffer(size, s);
  return (async function* () {
    let buf: T[] = []
    for await (const item of stream) {
      buf.push(item)
      if (buf.length >= size) yield buf = []
    }
    if (buf.length > 0) yield buf
  })();
}
// unnamed ends here

// [[file:index.org::17560]]
/**
 * Collects values over a time window, emitting the buffer when the window closes.
 * Continues creating new windows until the source completes.
 */
export function bufferTime<T>(
  ms: number
): (stream: AsyncIterable<T>) => AsyncGenerator<T[], void, void>;
export function bufferTime<T>(
  ms: number,
  stream: AsyncIterable<T>
): AsyncGenerator<T[], void, void>;
export function bufferTime<T>(
  ms: number,
  stream?: AsyncIterable<T>,
): AsyncGenerator<T[], void, void> | ((stream: AsyncIterable<T>) => AsyncGenerator<T[], void, void>) {
  if (stream === undefined) return (s: AsyncIterable<T>) => bufferTime(ms, s);
  return (async function* () {
    const iterator = stream[Symbol.asyncIterator]()
    let currentBuffer: T[] = []
    let done = false
    let bufferResolve: (() => void) | null = null

    // Timer that fires to emit buffer
    const startTimer = () => {
      return new Promise<'timer'>(resolve => {
        setTimeout(() => resolve('timer'), ms)
      })
    }

    // Source consumer
    const getNext = async (): Promise<{ done: true } | { done: false; value: T }> => {
      const result = await iterator.next()
      return result.done ? { done: true } : { done: false, value: result.value }
    }

    let timerPromise = startTimer()
    let nextPromise = getNext()

    while (!done) {
      const result = await Promise.race([timerPromise, nextPromise])

      if (result === 'timer') {
        // Timer fired - emit buffer and restart timer
        if (currentBuffer.length > 0) {
          yield currentBuffer
          currentBuffer = []
        }
        timerPromise = startTimer()
      } else if (result.done) {
        // Source completed
        done = true
        if (currentBuffer.length > 0) {
          yield currentBuffer
        }
      } else {
        // Got a value
        currentBuffer.push(result.value)
        nextPromise = getNext()
      }
    }
  })();
}
// unnamed ends here

// [[file:index.org::18037]]
/**
 * Splits the source into windows of the specified size.
 * Each window is emitted as a separate async iterable.
 */
export function window<T>(
  size: number
): (stream: AsyncIterable<T>) => AsyncGenerator<AsyncIterable<T>, void, void>;
export function window<T>(
  size: number,
  stream: AsyncIterable<T>
): AsyncGenerator<AsyncIterable<T>, void, void>;
export function window<T>(
  size: number,
  stream?: AsyncIterable<T>,
): AsyncGenerator<AsyncIterable<T>, void, void> | ((stream: AsyncIterable<T>) => AsyncGenerator<AsyncIterable<T>, void, void>) {
  if (stream === undefined) return (s: AsyncIterable<T>) => window(size, s);
  return (async function* () {
    const iterator = stream[Symbol.asyncIterator]()
    let done = false

    while (!done) {
      let count = 0
      const windowValues: T[] = []
      let windowDone = false
      let windowResolve: ((result: IteratorResult<T>) => void) | null = null

      // Create a window stream
      const windowStream: AsyncIterable<T> = {
        [Symbol.asyncIterator]() {
          let index = 0
          return {
            async next(): Promise<IteratorResult<T>> {
              if (index < windowValues.length) return { value: windowValues[index++], done: false }
              if (windowDone) return { value: undefined as any, done: true }
              return new Promise(resolve => { windowResolve = resolve } )
            }
          }
        }
      }

      // Yield the window stream
      yield windowStream

      // Fill the window
      while (count < size && !done) {
        const result = await iterator.next()
        if (result.done) {
          done = true
          windowDone = true
          if (windowResolve) {
            const resolver: (result: IteratorResult<T>) => void = windowResolve
            resolver({ value: undefined as any, done: true })
          }
        } else {
          windowValues.push(result.value)
          count++
          if (windowResolve) {
            const resolver: (result: IteratorResult<T>) => void = windowResolve
            windowResolve = null
            resolver({ value: result.value, done: false })
          }
        }
      }
      windowDone = true
      if (windowResolve) {
        const resolver: (result: IteratorResult<T>) => void = windowResolve
        resolver({ value: undefined as any, done: true })
      }
    }
  })();
}
// unnamed ends here

// [[file:index.org::18330]]
/**
 * Pre-fetches up to `bufferSize` values from a slow producer, caching them for fast downstream access.
 * Starts buffering lazily when the first value is requested.
 * 
 * @param bufferSize - Maximum values to pre-fetch. Use 0 for unlimited (careful with infinite streams!)
 * 
 * @example
 * // Pre-fetch 5 file contents while processing
 * const files = pipe(
 *   filePathStream,
 *   map(path => fs.readFile(path)),
 *   eager(5)  // Buffer up to 5 files ahead
 * )
 */
export function eager<T>(
  bufferSize: number
): (stream: AsyncIterable<T>) => AsyncGenerator<T, void, void>;
export function eager<T>(
  bufferSize: number,
  stream: AsyncIterable<T>
): AsyncGenerator<T, void, void>;
export function eager<T>(
  bufferSize: number,
  stream?: AsyncIterable<T>,
): AsyncGenerator<T, void, void> | ((stream: AsyncIterable<T>) => AsyncGenerator<T, void, void>) {
  if (stream === undefined) return (s: AsyncIterable<T>) => eager(bufferSize, s);
  return (async function* () {
    const iterator = stream[Symbol.asyncIterator]()
    const buffer: T[] = []
    let error: Error | null = null
    let done = false
    let consuming = false
    let waitingResolve: (() => void) | null = null

    const startConsuming = () => {
      if (consuming) return
      consuming = true
      
      // Consume source in background
      ;(async () => {
        try {
          while (!done) {
            // Respect buffer limit (0 = unlimited)
            if (bufferSize > 0 && buffer.length >= bufferSize) {
              // Wait for buffer to drain
              await new Promise<void>(r => { waitingResolve = r })
              continue
            }
            
            const result = await iterator.next()
            if (result.done) done = true
            else buffer.push(result.value)
          }
        } catch (e) {
          error = e as Error
          done = true
        }
      })()
    }

    // Start consuming on first pull
    startConsuming()

    while (true) {
      // Yield buffered values first
      if (buffer.length > 0) {
        const value = buffer.shift()!
        // Signal that buffer has space
        if (waitingResolve) {
          const resolver: () => void = waitingResolve
          waitingResolve = null
          resolver()
        }
        yield value
      }
      else if (error) throw error // Emit buffered values before error (requirement)
      else if (done) break
      else await new Promise<void>(r => setTimeout(r, 1)) // Wait for more values
    }
  })();
}

/**
 * Pre-fetches up to `bufferSize` values from a slow producer immediately on creation.
 * Like `eager`, but starts consuming right away rather than waiting for the first pull.
 * 
 * @param bufferSize - Maximum values to pre-fetch. Use 0 for unlimited (careful with infinite streams!)
 */
export function eagerNow<T>(
  bufferSize: number
): (stream: AsyncIterable<T>) => AsyncIterable<T>;
export function eagerNow<T>(
  bufferSize: number,
  stream: AsyncIterable<T>
): AsyncIterable<T>;
export function eagerNow<T>(
  bufferSize: number,
  stream?: AsyncIterable<T>,
): AsyncIterable<T> | ((stream: AsyncIterable<T>) => AsyncIterable<T>) {
  if (stream === undefined) return (s: AsyncIterable<T>) => eagerNow(bufferSize, s);
  
  const iterator = stream[Symbol.asyncIterator]()
  const buffer: T[] = []
  let error: Error | null = null
  let done = false
  let waitingResolves: (() => void)[] = []

  // Start consuming immediately
  ;(async () => {
    try {
      while (!done) {
        // Respect buffer limit (0 = unlimited)
        if (bufferSize > 0 && buffer.length >= bufferSize) {
          await new Promise<void>(r => { waitingResolves.push(r) })
          continue
        }
        
        const result = await iterator.next()
        if (result.done) done = true
        else buffer.push(result.value)
      }
    } catch (e) {
      error = e as Error
      done = true
    }
  })()

  return {
    [Symbol.asyncIterator]() {
      return {
        async next(): Promise<IteratorResult<T>> {
          while (true) {
            if (buffer.length > 0) {
              const value = buffer.shift()!
              // Signal that buffer has space
              if (waitingResolves.length > 0) {
                const resolve = waitingResolves.shift()!
                resolve()
              }
              return { value, done: false }
            }
            else if (error) throw error
            else if (done) return { value: undefined as any, done: true }
            else await new Promise<void>(r => setTimeout(r, 1))
          }
        }
      }
    }
  }
}
// unnamed ends here

// [[file:index.org::18964]]
/**
 * A multicasting subject that replays buffered values to new subscribers.
 * 
 * @example
 * const subject = new ReplaySubject<number>(2)  // buffer last 2 values
 * 
 * // Push values
 * subject.next(1)
 * subject.next(2)
 * subject.next(3)
 * 
 * // New subscriber gets [2, 3] immediately, then live values
 * for await (const value of subject) { ... }
 */
export class ReplaySubject<T> implements AsyncIterable<T> {
  private buffer: T[] = []
  private subscribers: Set<{
    queue: T[]
    resolve: ((result: IteratorResult<T>) => void) | null
  }> = new Set()
  private completed = false
  private error: Error | null = null

  constructor(private bufferSize: number = Infinity) {}

  /**
   * Push a value to all subscribers.
   */
  next(value: T): void {
    if (this.completed) throw new Error('Cannot push to completed ReplaySubject')
    
    // Add to buffer
    this.buffer.push(value)
    if (this.buffer.length > this.bufferSize) {
      this.buffer.shift()
    }

    // Notify all subscribers
    for (const sub of this.subscribers) {
      if (sub.resolve) {
        const resolve = sub.resolve
        sub.resolve = null
        resolve({ value, done: false })
      } else {
        sub.queue.push(value)
      }
    }
  }

  /**
   * Signal completion to all subscribers.
   */
  complete(): void {
    this.completed = true
    for (const sub of this.subscribers) {
      if (sub.resolve) {
        const resolve = sub.resolve
        sub.resolve = null
        resolve({ value: undefined as T, done: true })
      }
    }
  }

  /**
   * Signal an error to all subscribers.
   */
  throw(error: Error): void {
    this.error = error
    this.completed = true
    // Subscribers will see the error on next pull
  }

  [Symbol.asyncIterator](): AsyncIterator<T> {
    const sub = {
      queue: [...this.buffer],  // Start with buffered values
      resolve: null as ((result: IteratorResult<T>) => void) | null
    }
    this.subscribers.add(sub)

    return {
      next: async (): Promise<IteratorResult<T>> => {
        // Check for error
        if (this.error) throw this.error
        
        // Return queued value if available
        if (sub.queue.length > 0) {
          return { value: sub.queue.shift()!, done: false }
        }
        
        // Check if completed
        if (this.completed) {
          this.subscribers.delete(sub)
          return { value: undefined as T, done: true }
        }

        // Wait for next value
        return new Promise(resolve => {
          sub.resolve = resolve
        })
      },
      return: async (): Promise<IteratorResult<T>> => {
        this.subscribers.delete(sub)
        return { value: undefined as T, done: true }
      }
    }
  }

  /**
   * Get the current buffer contents (snapshot).
   */
  getBuffer(): readonly T[] {
    return [...this.buffer]
  }

  /**
   * Number of active subscribers.
   */
  get subscriberCount(): number {
    return this.subscribers.size
  }
}
// unnamed ends here

// [[file:index.org::19483]]
/**
 * Makes a stream consumable by multiple consumers by buffering values.
 * 
 * @param bufferSize - Maximum number of values to buffer for replay (default: Infinity)
 * @param source - The source stream to multicast
 * @returns An AsyncIterable that can be consumed by multiple consumers
 * 
 * @example
 * const shared = replay(2, sourceStream)
 * 
 * // Consumer 1 starts
 * const consumer1 = collect(shared)
 * 
 * // Consumer 2 joins later, gets last 2 values + live values
 * const consumer2 = collect(shared)
 */
export function replay<T>(
  bufferSize: number,
  source: AsyncIterable<T>,
): AsyncIterable<T> {
  const subject = new ReplaySubject<T>(bufferSize)
  let started = false

  const startSource = () => {
    if (started) return
    started = true
    
    ;(async () => {
      try {
        for await (const value of source) { subject.next(value) }
        subject.complete()
      } catch (e) { subject.throw(e as Error) }
    })()
  }

  return {
    [Symbol.asyncIterator](): AsyncIterator<T> {
      startSource()
      return subject[Symbol.asyncIterator]()
    }
  }
}
// unnamed ends here

// [[file:index.org::20044]]
/**
 * Shares a stream among multiple consumers without buffering.
 * New subscribers only receive values emitted after subscription.
 * 
 * @example
 * const shared = share(sourceStream)
 * const consumer1 = shared[Symbol.asyncIterator]()
 * // ... later ...
 * const consumer2 = shared[Symbol.asyncIterator]()
 * // consumer2 misses values emitted before subscription
 */
export function share<T>(source: AsyncIterable<T>): AsyncIterable<T> {
  return replay(0, source)
}
// unnamed ends here

// [[file:index.org::20384]]
/**
 * Creates a factory that produces independent copies of a buffered stream.
 * 
 * @param bufferSize - Maximum values to buffer
 * @param source - The source stream
 * @returns A function that creates new stream copies
 * 
 * @example
 * const factory = replayFactory(Infinity, sourceStream)
 * 
 * const copy1 = factory()  // Gets all values from beginning
 * const copy2 = factory()  // Also gets all values from beginning
 */
export function replayFactory<T>(
  bufferSize: number,
  source: AsyncIterable<T>,
): () => AsyncIterable<T> {
  const subject = new ReplaySubject<T>(bufferSize)
  let started = false

  const startSource = () => {
    if (started) return
    started = true
    
    ;(async () => {
      try {
        for await (const value of source) {
          subject.next(value)
        }
        subject.complete()
      } catch (e) {
        subject.throw(e as Error)
      }
    })()
  }

  return () => {
    startSource()
    return {
      [Symbol.asyncIterator]: () => subject[Symbol.asyncIterator]()
    }
  }
}
// unnamed ends here

// [[file:index.org::20804]]
/**
 * Returns a stream that emits independent copies of the source stream.
 * Each pull creates a new subscriber that receives buffered + live values.
 * 
 * @example
 * const copies = replayStream(2, sourceStream)
 * 
 * for await (const streamCopy of copies) {
 *   // Each streamCopy is an independent consumer
 *   processStream(streamCopy)
 * }
 */
export async function* replayStream<T>(
  bufferSize: number,
  source: AsyncIterable<T>,
): AsyncGenerator<AsyncIterable<T>, void, void> {
  const factory = replayFactory(bufferSize, source)
  
  // Emit copies indefinitely until the caller stops asking
  while (true) {
    yield factory()
  }
}
// unnamed ends here
