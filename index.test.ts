// This file is auto-generated by organjsm tangle. Do not edit directly.
// Source: index.org

// [[file:index.org::23127]]
import { describe, it, expect } from 'vitest'
import {
  collect,
  collectN,
  collectWithTime,
  marble,
  TestStream,
  spy,
  expectStream,
  createAsyncIterable
} from './test-helpers'
import {
  just,
  from,
  fromPromise,
  fromEvent,
  periodic,
  empty,
  never,
  iterate,
  unfold,
  startWith,
  concat,
  pipe,
  map,
  constant,
  scan,
  tap,
  awaitTap,
  continueWith,
  concatAll,
  concatMap,
  filter,
  skipRepeats,
  skipRepeatsWith,
  take,
  skip,
  slice,
  takeWhile,
  skipWhile,
  takeUntil,
  delay,
  debounce,
  throttle,
  recoverWith,
  throwError,
  retry,
  merge,
  mergeAll,
  chain,
  flatMap,
  switchMap,
  latest,
  applyLatest,
  untilStream,
  sinceStream,
  buffer,
  bufferTime,
  window,
  eager,
  eagerNow,
  ReplaySubject,
  replay,
  share,
  replayFactory,
  replayStream
} from './index'

describe('just', () => {
  it('emits a single value and completes', async () => {
    const values = await collect(just(42))
    expect(values).toEqual([42])
  })
})

describe('fromPromise', () => {
  it('emits the resolved value', async () => {
    const values = await collect(fromPromise(Promise.resolve(42)))
    expect(values).toEqual([42])
  })

  it('waits for promise resolution', async () => {
    const delayed = new Promise<string>(r => setTimeout(() => r('delayed'), 10))
    const values = await collect(fromPromise(delayed))
    expect(values).toEqual(['delayed'])
  })

  it('propagates rejection as error', async () => {
    const failing = Promise.reject(new Error('fail'))
    await expect(collect(fromPromise(failing))).rejects.toThrow('fail')
  })
})

describe('fromSeq', () => {
  it('emits all values from an array', async () => {
    const values = await collect(from([1, 2, 3]))
    expect(values).toEqual([1, 2, 3])
  })
  it('handles empty arrays', async () => {
    await expectStream(from([])).toBeEmpty()
  })
})

describe('periodic', () => {
  it('emits void values at intervals', async () => {
    const values = await collect(pipe(periodic(10), take(3)))
    expect(values).toEqual([undefined, undefined, undefined])
  })
})

describe('empty', () => {
  it('completes immediately without emitting', async () => {
    await expectStream(empty()).toBeEmpty()
  })
})

describe('never', () => {
  it('never emits or completes', async () => {
    // We can only test that it doesn't immediately complete
    let completed = false
    const gen = never()
    const timeout = setTimeout(() => {}, 50)
    
    // Race the never stream against a timeout
    const result = await Promise.race([
      gen.next().then(() => 'emitted'),
      new Promise<string>(r => setTimeout(() => r('timeout'), 20))
    ])
    clearTimeout(timeout)
    expect(result).toBe('timeout')
  })
})

describe('iterate', () => {
  it('generates values by applying function repeatedly', async () => {
    const values = await collect(pipe(iterate(1, x => x * 2), take(5)))
    expect(values).toEqual([1, 2, 4, 8, 16])
  })

  it('starts with the seed value', async () => {
    const values = await collect(pipe(iterate(10, x => x + 1), take(3)))
    expect(values).toEqual([10, 11, 12])
  })
})

describe('unfold', () => {
  it('generates values until done is true', async () => {
    const values = await collect(unfold(1, n => ({
      value: n,
      nextSeed: n + 1,
      done: n > 3
    })))
    expect(values).toEqual([1, 2, 3])
  })

  it('completes immediately if first call returns done', async () => {
    const values = await collect(unfold(0, () => ({
      value: 'ignored',
      nextSeed: 0,
      done: true
    })))
    expect(values).toEqual([])
  })
})

describe('startWith', () => {
  it('prepends value to stream', async () => {
    const values = await collect(startWith(0, from([1, 2, 3])))
    expect(values).toEqual([0, 1, 2, 3])
  })

  it('works with empty stream', async () => {
    const values = await collect(startWith('first', empty()))
    expect(values).toEqual(['first'])
  })
})

describe('concat', () => {
  it('concatenates streams in order', async () => {
    const result = await collect(concat(from([1, 2]), from([3, 4])))
    expect(result).toEqual([1, 2, 3, 4])
  })
})

describe('fromEvent', () => {
  it('creates stream from event emitter', async () => {
    // Create a mock event target
    type Listener = (event: string) => void
    const listeners: Listener[] = []
    const mockTarget = {
      addEventListener(_type: string, listener: Listener) {
        listeners.push(listener)
      },
      removeEventListener(_type: string, listener: Listener) {
        const idx = listeners.indexOf(listener)
        if (idx >= 0) listeners.splice(idx, 1)
      },
      emit(event: string) {
        listeners.forEach(l => l(event))
      }
    }

    const events = fromEvent<string>(mockTarget, 'test')
    const iter = events[Symbol.asyncIterator]()

    // Emit some events
    mockTarget.emit('event1')
    mockTarget.emit('event2')

    const first = await iter.next()
    expect(first.value).toBe('event1')

    const second = await iter.next()
    expect(second.value).toBe('event2')

    // Cleanup
    await iter.return!()
    expect(listeners.length).toBe(0)
  })

  it('removes listener on return', async () => {
    let listenerCount = 0
    const mockTarget = {
      addEventListener() { listenerCount++ },
      removeEventListener() { listenerCount-- }
    }

    const events = fromEvent(mockTarget, 'test')
    const iter = events[Symbol.asyncIterator]()
    expect(listenerCount).toBe(1)

    await iter.return!()
    expect(listenerCount).toBe(0)
  })
})

describe('map', () => {
  it('transforms each value', async () => {
    const result = await collect(map(x => x * 2, from([1, 2, 3])))
    expect(result).toEqual([2, 4, 6])
  })

  it('handles async mappers', async () => {
    const result = await collect(
      map(async x => x * 2, from([1, 2, 3]))
    )
    expect(result).toEqual([2, 4, 6])
  })
})

describe('constant', () => {
  it('replaces each value with the constant', async () => {
    const values = await collect(constant('x', from([1, 2, 3])))
    expect(values).toEqual(['x', 'x', 'x'])
  })

  it('emits nothing for empty stream', async () => {
    const values = await collect(constant('x', empty()))
    expect(values).toEqual([])
  })
})

describe('scan', () => {
  it('accumulates values starting with seed', async () => {
    const result = await collect(scan((acc, x) => acc + x, 0, from([1, 2, 3])))
    expect(result).toEqual([0, 1, 3, 6])
  })
})

describe('tap', () => {
  it('performs side effect without modifying values', async () => {
    const sideEffects: number[] = []
    const values = await collect(tap(x => { sideEffects.push(x) }, from([1, 2, 3])))
    expect(values).toEqual([1, 2, 3])
    expect(sideEffects).toEqual([1, 2, 3])
  })

  it('does not await async side effects', async () => {
    const order: string[] = []
    const values = await collect(tap(async x => {
      await new Promise(r => setTimeout(r, 10))
      order.push(`effect-${x}`)
    }, from([1, 2])))
    order.push('done')
    expect(values).toEqual([1, 2])
    // 'done' should appear before effects complete since tap doesn't await
    expect(order[0]).toBe('done')
  })
})

describe('awaitTap', () => {
  it('awaits side effect before yielding', async () => {
    const order: string[] = []
    const values = await collect(awaitTap(async x => {
      await new Promise(r => setTimeout(r, 5))
      order.push(`effect-${x}`)
    }, from([1, 2])))
    order.push('done')
    expect(values).toEqual([1, 2])
    // Effects should complete before 'done' since awaitTap awaits
    expect(order).toEqual(['effect-1', 'effect-2', 'done'])
  })
})

describe('continueWith', () => {
  it('continues with another stream after first completes', async () => {
    const values = await collect(continueWith(
      () => from([4, 5]),
      from([1, 2, 3])
    ))
    expect(values).toEqual([1, 2, 3, 4, 5])
  })

  it('calls continuation function only after first stream completes', async () => {
    let called = false
    const values = await collect(continueWith(
      () => { called = true; return from([99]) },
      from([1])
    ))
    expect(called).toBe(true)
    expect(values).toEqual([1, 99])
  })
})

describe('concatAll', () => {
  it('flattens stream of streams in order', async () => {
    const streams = from([from([1, 2]), from([3, 4]), from([5])])
    const values = await collect(concatAll(streams))
    expect(values).toEqual([1, 2, 3, 4, 5])
  })

  it('handles empty outer stream', async () => {
    const values = await collect(concatAll(empty()))
    expect(values).toEqual([])
  })
})

describe('concatMap', () => {
  it('maps and flattens in order', async () => {
    const values = await collect(concatMap(
      x => from([x, x * 10]),
      from([1, 2, 3])
    ))
    expect(values).toEqual([1, 10, 2, 20, 3, 30])
  })

  it('handles mapper returning empty stream', async () => {
    const values = await collect(concatMap(
      x => x > 1 ? from([x]) : empty(),
      from([1, 2, 3])
    ))
    expect(values).toEqual([2, 3])
  })
})

describe('filter', () => {
  it('keeps values matching predicate', async () => {
    const result = await collect(filter(x => x % 2 === 0, from([1, 2, 3, 4])))
    expect(result).toEqual([2, 4])
  })
})

describe('skipRepeats', () => {
  it('filters consecutive duplicates', async () => {
    const values = await collect(skipRepeats(from([1, 1, 2, 2, 3, 1, 1])))
    expect(values).toEqual([1, 2, 3, 1])
  })

  it('handles empty stream', async () => {
    const values = await collect(skipRepeats(empty()))
    expect(values).toEqual([])
  })

  it('handles single value', async () => {
    const values = await collect(skipRepeats(from([42])))
    expect(values).toEqual([42])
  })
})

describe('skipRepeatsWith', () => {
  it('filters based on custom equality', async () => {
    const values = await collect(skipRepeatsWith(
      (a, b) => Math.floor(a) === Math.floor(b),
      from([1.1, 1.2, 2.1, 2.2, 3.0])
    ))
    expect(values).toEqual([1.1, 2.1, 3.0])
  })

  it('supports async predicate', async () => {
    const values = await collect(skipRepeatsWith(
      async (a, b) => a === b,
      from([1, 1, 2])
    ))
    expect(values).toEqual([1, 2])
  })
})

describe('take', () => {
  it('takes only first N values', async () => {
    const result = await collect(take(2, from([1, 2, 3, 4, 5])))
    expect(result).toEqual([1, 2])
  })
})

describe('skip', () => {
  it('skips first N values', async () => {
    const result = await collect(skip(2, from([1, 2, 3, 4, 5])))
    expect(result).toEqual([3, 4, 5])
  })
})

describe('slice', () => {
  it('emits values from start to end indices', async () => {
    const values = await collect(slice(1, 4, from([0, 1, 2, 3, 4, 5])))
    expect(values).toEqual([1, 2, 3])
  })
  it('handles start at 0', async () => {
    const values = await collect(slice(0, 2, from([10, 20, 30])))
    expect(values).toEqual([10, 20])
  })
  it('returns empty for out of range', async () => {
    const values = await collect(slice(10, 20, from([1, 2, 3])))
    expect(values).toEqual([])
  })
})

describe('takeWhile', () => {
  it('takes while predicate is true', async () => {
    const values = await collect(takeWhile(x => x < 4, from([1, 2, 3, 4, 5])))
    expect(values).toEqual([1, 2, 3])
  })
  it('stops at first false', async () => {
    const values = await collect(takeWhile(x => x !== 'stop', from(['a', 'b', 'stop', 'c'])))
    expect(values).toEqual(['a', 'b'])
  })
})

describe('skipWhile', () => {
  it('skips while predicate is true then emits rest', async () => {
    const values = await collect(skipWhile(x => x < 3, from([1, 2, 3, 4, 2, 1])))
    expect(values).toEqual([3, 4, 2, 1])
  })
  it('emits all if predicate never true', async () => {
    const values = await collect(skipWhile(() => false, from([1, 2, 3])))
    expect(values).toEqual([1, 2, 3])
  })
})

describe('takeUntil', () => {
  it('takes until predicate matches (exclusive)', async () => {
    const values = await collect(takeUntil(x => x === 3, from([1, 2, 3, 4, 5])))
    expect(values).toEqual([1, 2])
  })

  it('emits all if predicate never matches', async () => {
    const values = await collect(takeUntil(() => false, from([1, 2, 3])))
    expect(values).toEqual([1, 2, 3])
  })
})

describe('delay', () => {
  it('delays each emission', async () => {
    const start = Date.now()
    const values = await collect(delay(20, from([1, 2, 3])))
    const elapsed = Date.now() - start
    expect(values).toEqual([1, 2, 3])
    expect(elapsed).toBeGreaterThanOrEqual(50)
  })

  it('supports curried form', async () => {
    const values = await collect(pipe(from([1, 2]), delay(10)))
    expect(values).toEqual([1, 2])
  })
})

describe('debounce', () => {
  it('only emits after stream settles', async () => {
    const stream = createAsyncIterable([1, 2, 3], { delay: 10 })
    const values = await collect(debounce(30, stream))
    // Only the last value should be emitted since delay < debounce time
    expect(values).toEqual([3])
  })

  it('emits multiple values when gaps are large enough', async () => {
    const stream = createAsyncIterable([1, 2], { delay: 50 })
    const values = await collect(debounce(20, stream))
    // Both should emit since delay > debounce time
    expect(values).toEqual([1, 2])
  })

  it('supports curried form', async () => {
    const values = await collect(pipe(from([1]), debounce(5)))
    expect(values).toEqual([1])
  })
})

describe('throttle', () => {
  it('limits emission rate with default options', async () => {
    const stream = createAsyncIterable([1, 2, 3, 4, 5], { delay: 10 })
    const values = await collect(throttle(25, {}, stream))
    // First emits immediately, then throttled
    expect(values.length).toBeLessThan(5)
    expect(values[0]).toBe(1)
  })

  it('respects leading: false', async () => {
    const values = await collect(throttle(50, { leading: false }, from([1, 2, 3])))
    // Should not emit leading values
    expect(values.length).toBeGreaterThan(0)
  })

  it('respects trailing: false', async () => {
    const stream = createAsyncIterable([1, 2, 3], { delay: 5 })
    const values = await collect(throttle(20, { trailing: false }, stream))
    // Should only emit leading values
    expect(values).toContain(1)
  })

  it('supports curried form', async () => {
    const values = await collect(pipe(from([1, 2, 3]), throttle(10)))
    expect(values.length).toBeGreaterThan(0)
  })
})

describe('recoverWith', () => {
  it('yields values from recovery stream on error', async () => {
    const failing = throwError(new Error('oops'))
    const values = await collect(recoverWith(
      () => from([1, 2, 3]),
      failing
    ))
    expect(values).toEqual([1, 2, 3])
  })

  it('passes error to recovery function', async () => {
    let capturedError: Error | undefined
    const failing = throwError(new Error('captured'))
    await collect(recoverWith(
      (e: Error) => { capturedError = e; return empty() },
      failing
    ))
    expect(capturedError?.message).toBe('captured')
  })

  it('yields source values if no error', async () => {
    const values = await collect(recoverWith(
      () => from(['fallback']),
      from(['success'])
    ))
    expect(values).toEqual(['success'])
  })
})

describe('throwError', () => {
  it('creates a stream that immediately errors', async () => {
    await expectStream(throwError(new Error('test error')))
      .toErrorWith('test error')
  })
})

describe('retry', () => {
  it('retries on error up to maxAttempts', async () => {
    let attempts = 0
    const values = await collect(retry(3, () => {
      attempts++
      if (attempts < 3) return throwError(new Error('fail'))
      return from([1, 2, 3])
    }))
    expect(attempts).toBe(3)
    expect(values).toEqual([1, 2, 3])
  })

  it('throws after maxAttempts exceeded', async () => {
    let attempts = 0
    await expect(collect(retry(2, () => {
      attempts++
      return throwError(new Error('always fails'))
    }))).rejects.toThrow('always fails')
    expect(attempts).toBe(2)
  })

  it('supports options object', async () => {
    let attempts = 0
    await collect(retry({ maxAttempts: 2, delayMs: 10 }, () => {
      attempts++
      if (attempts < 2) return throwError(new Error('fail'))
      return from(['ok'])
    }))
    expect(attempts).toBe(2)
  })

  it('supports shouldRetry predicate', async () => {
    let attempts = 0
    await expect(collect(retry({
      maxAttempts: 5,
      shouldRetry: (err, attempt) => attempt < 2
    }, () => {
      attempts++
      return throwError(new Error('fail'))
    }))).rejects.toThrow('fail')
    expect(attempts).toBe(2)
  })
})

describe('merge', () => {
  it('merges multiple streams', async () => {
    const a = createAsyncIterable([1, 3], { delay: 20 })
    const b = createAsyncIterable([2, 4], { delay: 20, initialDelay: 10 })
    const result = await collect(merge(a, b))
    expect(result).toEqual([1, 2, 3, 4])
  })
})

describe('mergeAll', () => {
  it('flattens stream of streams concurrently', async () => {
    const streams = from([from([1, 2]), from([3, 4])])
    const values = await collect(mergeAll(streams))
    // Order may vary, but all values should be present
    expect(values.sort()).toEqual([1, 2, 3, 4])
  })

  it('handles empty outer stream', async () => {
    const values = await collect(mergeAll(empty()))
    expect(values).toEqual([])
  })
})

describe('chain / flatMap', () => {
  it('maps and merges inner streams', async () => {
    const values = await collect(chain(
      x => from([x, x * 10]),
      from([1, 2])
    ))
    // All values present, order may vary due to merging
    expect(values.sort((a, b) => a - b)).toEqual([1, 2, 10, 20])
  })

  it('flatMap is an alias for chain', () => {
    expect(flatMap).toBe(chain)
  })
})

describe('switchMap', () => {
  it('cancels previous inner stream on new outer value', async () => {
    // Fast outer, slow inner - should cancel early inner streams
    const outer = createAsyncIterable([1, 2, 3], { delay: 10 })
    const values = await collect(switchMap(
      x => createAsyncIterable([x * 10, x * 100], { delay: 30 }),
      outer
    ))
    // Only values from the last inner stream should complete
    expect(values).toContain(30)
    expect(values).toContain(300)
  })

  it('supports curried form', async () => {
    const values = await collect(pipe(
      from([1]),
      switchMap(x => from([x, x * 2]))
    ))
    expect(values).toEqual([1, 2])
  })

  it('completes when outer and inner complete', async () => {
    const values = await collect(switchMap(
      x => from([x]),
      from([1, 2, 3])
    ))
    expect(values.length).toBeGreaterThan(0)
  })
})

describe('latest', () => {
  it('emits tuple of latest values after all streams have emitted', async () => {
    const a = from([1, 2])
    const b = from(['x', 'y'])
    const values = await collect(latest([a, b]))
    // After both emit, we should get tuples
    expect(values.length).toBeGreaterThan(0)
    // Each tuple should have a number and string
    values.forEach(([n, s]) => {
      expect(typeof n).toBe('number')
      expect(typeof s).toBe('string')
    })
  })
})

describe('applyLatest', () => {
  it('applies latest function to latest value', async () => {
    const fns = from([(x: number) => x * 2, (x: number) => x * 3])
    const vals = from([10, 20])
    const values = await collect(applyLatest(fns, vals))
    expect(values.length).toBeGreaterThan(0)
    // Results should be numbers
    values.forEach(v => expect(typeof v).toBe('number'))
  })
})

describe('untilStream', () => {
  it('stops when stop stream emits', async () => {
    // Source emits forever, stop after 3 items
    const source = pipe(iterate(1, x => x + 1), take(10))
    const stop = pipe(from([1, 2, 3]), skip(2)) // emits on 3rd
    // This test is tricky with sync streams - use take to limit
    const values = await collect(pipe(untilStream(stop, from([1, 2, 3, 4, 5])), take(5)))
    expect(values.length).toBeLessThanOrEqual(5)
  })
})

describe('sinceStream', () => {
  it('emits only after start stream emits', async () => {
    // With sync streams, behavior depends on interleaving
    const start = just('go')
    const source = from([1, 2, 3, 4, 5])
    const values = await collect(sinceStream(start, source))
    // Should emit some subset after start signal
    expect(Array.isArray(values)).toBe(true)
  })
})

describe('buffer', () => {
  it('collects values into fixed-size arrays', async () => {
    const values = await collect(buffer(2, from([1, 2, 3, 4, 5])))
    expect(values).toEqual([[1, 2], [3, 4], [5]])
  })

  it('emits partial buffer at end', async () => {
    const values = await collect(buffer(3, from([1, 2])))
    expect(values).toEqual([[1, 2]])
  })

  it('supports curried form', async () => {
    const values = await collect(pipe(from([1, 2, 3, 4]), buffer(2)))
    expect(values).toEqual([[1, 2], [3, 4]])
  })
})

describe('bufferTime', () => {
  it('collects values over time window', async () => {
    const stream = createAsyncIterable([1, 2, 3, 4], { delay: 15 })
    const values = await collect(bufferTime(35, stream))
    // With 15ms delay between items and 35ms window:
    // Window 1 (0-35ms): 1, 2
    // Window 2 (35-70ms): 3, 4
    expect(values.length).toBeGreaterThanOrEqual(1)
    expect(values.flat()).toEqual([1, 2, 3, 4])
  })

  it('supports curried form', async () => {
    const values = await collect(pipe(from([1, 2]), bufferTime(50)))
    expect(values.flat()).toEqual([1, 2])
  })
})

describe('window', () => {
  it('splits stream into window streams', async () => {
    const windows = await collect(window(2, from([1, 2, 3, 4, 5])))
    expect(windows.length).toBe(3)
    
    const values = await Promise.all(windows.map(w => collect(w)))
    expect(values).toEqual([[1, 2], [3, 4], [5]])
  })

  it('supports curried form', async () => {
    const windows = await collect(pipe(from([1, 2, 3]), window(2)))
    expect(windows.length).toBe(2)
  })
})

describe('eager', () => {
  it('pre-fetches values from slow producer', async () => {
    let fetchCount = 0
    const slowStream = async function* () {
      for (let i = 1; i <= 5; i++) {
        fetchCount++
        await new Promise(r => setTimeout(r, 20))
        yield i
      }
    }

    const eagerStream = eager(3, slowStream())
    
    // First pull starts fetching
    const iter = eagerStream[Symbol.asyncIterator]()
    await new Promise(r => setTimeout(r, 70)) // Let it buffer
    
    // Should have pre-fetched some values
    const result = await iter.next()
    expect(result.value).toBe(1)
  })

  it('respects buffer size limit', async () => {
    const values = await collect(eager(2, from([1, 2, 3, 4, 5])))
    expect(values).toEqual([1, 2, 3, 4, 5])
  })

  it('supports curried form', async () => {
    const values = await collect(pipe(from([1, 2, 3]), eager(2)))
    expect(values).toEqual([1, 2, 3])
  })

  it('emits buffered values then error', async () => {
    // This tests that buffered values are emitted before error
    const failingStream = async function* () {
      yield 1
      yield 2
      throw new Error('fail')
    }
    
    try {
      const values = await collect(eager(5, failingStream()))
      // Should have gotten values before error
      expect(values).toContain(1)
    } catch (e) {
      // Error is expected
      expect((e as Error).message).toBe('fail')
    }
  })
})

describe('eagerNow', () => {
  it('starts buffering immediately', async () => {
    let started = false
    const slowStream = async function* () {
      started = true
      yield 1
    }

    const eager = eagerNow(3, slowStream())
    
    // Give it time to start
    await new Promise(r => setTimeout(r, 10))
    
    // Should have started consuming
    expect(started).toBe(true)
    
    const values = await collect(eager)
    expect(values).toEqual([1])
  })

  it('supports curried form', async () => {
    const eager = eagerNow(2)
    const values = await collect(eager(from([1, 2, 3])))
    expect(values).toEqual([1, 2, 3])
  })
})

describe('ReplaySubject', () => {
  it('replays buffered values to new subscribers', async () => {
    const subject = new ReplaySubject<number>(2)
    
    subject.next(1)
    subject.next(2)
    subject.next(3)
    subject.complete()
    
    // New subscriber gets last 2 values
    const values = await collect(subject)
    expect(values).toEqual([2, 3])
  })

  it('multicasts to multiple subscribers', async () => {
    const subject = new ReplaySubject<number>()
    
    // Start two consumers
    const consumer1: number[] = []
    const consumer2: number[] = []
    
    const iter1 = subject[Symbol.asyncIterator]()
    const iter2 = subject[Symbol.asyncIterator]()
    
    subject.next(1)
    subject.next(2)
    subject.complete()
    
    // Both should receive all values
    let result = await iter1.next()
    while (!result.done) {
      consumer1.push(result.value)
      result = await iter1.next()
    }
    
    result = await iter2.next()
    while (!result.done) {
      consumer2.push(result.value)
      result = await iter2.next()
    }
    
    expect(consumer1).toEqual([1, 2])
    expect(consumer2).toEqual([1, 2])
  })
})

describe('replay', () => {
  it('allows multiple consumers of a single source', async () => {
    const source = from([1, 2, 3])
    const shared = replay(Infinity, source)
    
    const values1 = await collect(shared)
    const values2 = await collect(shared)
    
    expect(values1).toEqual([1, 2, 3])
    expect(values2).toEqual([1, 2, 3])
  })

  it('respects buffer size', async () => {
    const source = from([1, 2, 3, 4, 5])
    const shared = replay(2, source)
    
    // First consumer triggers source consumption
    const values1 = await collect(shared)
    
    // Second consumer only gets last 2 buffered values
    const values2 = await collect(shared)
    
    expect(values1).toEqual([1, 2, 3, 4, 5])
    expect(values2).toEqual([4, 5])
  })
})

describe('share', () => {
  it('shares without buffering', async () => {
    const source = from([1, 2, 3])
    const shared = share(source)
    
    // First consumer gets all values
    const values1 = await collect(shared)
    
    // Second consumer gets nothing (no buffer)
    const values2 = await collect(shared)
    
    expect(values1).toEqual([1, 2, 3])
    expect(values2).toEqual([])
  })
})

describe('replayFactory', () => {
  it('creates factory that produces stream copies', async () => {
    const factory = replayFactory(Infinity, from([1, 2, 3]))
    
    const copy1 = await collect(factory())
    const copy2 = await collect(factory())
    
    expect(copy1).toEqual([1, 2, 3])
    expect(copy2).toEqual([1, 2, 3])
  })

  it('respects buffer size in replayFactory', async () => {
    const factory = replayFactory(2, from([1, 2, 3, 4, 5]))
    
    // First consumer gets all values and triggers buffering
    const copy1 = await collect(factory())
    expect(copy1).toEqual([1, 2, 3, 4, 5])
    
    // Second consumer only gets last 2 buffered values
    const copy2 = await collect(factory())
    expect(copy2).toEqual([4, 5])
  })
})

describe('replayStream', () => {
  it('emits stream copies', async () => {
    const copies = replayStream(Infinity, from([1, 2, 3]))
    
    // Get first copy
    const first = await copies.next()
    expect(first.done).toBe(false)
    
    // Collect values from the copy
    const values = await collect(first.value!)
    expect(values).toEqual([1, 2, 3])
  })
})

describe('TestStream', () => {
  it('allows manual value pushing', async () => {
    const stream = new TestStream<number>()
    
    // Push values async
    setTimeout(() => {
      stream.push(1)
      stream.push(2)
      stream.complete()
    }, 10)

    const values = await collect(stream)
    expect(values).toEqual([1, 2])
  })
})

describe('marble', () => {
  it('creates streams from marble diagrams', async () => {
    const stream = marble('-a-b-c|', { values: { a: 1, b: 2, c: 3 } })
    const result = await collect(stream)
    expect(result).toEqual([1, 2, 3])
  })
})

describe('collectWithTime', () => {
  it('records timing of emissions', async () => {
    const stream = createAsyncIterable([1, 2, 3], { delay: 50 })
    const result = await collectWithTime(stream)
    
    expect(result.map(r => r.value)).toEqual([1, 2, 3])
    expect(result[1].elapsed).toBeGreaterThanOrEqual(40)
    expect(result[2].elapsed).toBeGreaterThanOrEqual(90)
  })
})

describe('spy', () => {
  it('records stream events', async () => {
    const spied = spy(from([1, 2, 3]))
    await collect(spied.stream)
    
    expect(spied.values).toEqual([1, 2, 3])
    expect(spied.completed).toBe(true)
    expect(spied.events).toHaveLength(4) // 3 values + 1 complete
  })
})
// unnamed ends here
